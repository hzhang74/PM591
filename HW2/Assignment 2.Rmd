---
title: "PM 591 -- Machine Learning for the Health Sciences."
author: "Haoran Zhang"
date: "Due 2/14/2022"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1234)
```
<br>

### Analysis

1.  Brain weight data. 
    a. Using the function ``KNN.reg`` in the ``FNN`` package to construct predictive models for brain weight using KNN regression for $K=1,..,15$ on a training set (use the exact same training/validation split--same seed and same split percentages--you used for linear regression). Hint: use a for loop to iterate over $K$.
    
```{r}
library(FNN)
brain<-read.table("brain.txt", header = TRUE)
head(brain)

n = nrow(brain)
trainset = sample(1:n, floor(0.7*n))
brain_train = brain[trainset,]; n_train = nrow(brain_train)
brain_val = brain[-trainset,]; n_test = nrow(brain_val)

Rsq<-function(obs, pred){
  dif = obs - pred
  sqrt(mean(dif^2))
}

Rsq<-function(obs, pred){
  RSS = sum((obs-pred)^2)
  TSS = sum((obs-mean(obs))^2)
  R2 = 1-RSS/TSS
  print(R2)
}
```

```{r}
rmse <- data.frame(1:15,0,0)
colnames(rmse) <- c("k","rmse","R2")
for (i in 1:15){
  fit_nNN <- knn.reg(train = brain_train[,-4, drop = FALSE], test = brain_val[,-4, drop = FALSE], y = brain_train$Brain.weight, k = i)
  dif = brain_val$Brain.weight - fit_nNN$pred
  RSS = sum((brain_val$Brain.weight-fit_nNN$pred)^2)
  TSS = sum((brain_val$Brain.weight-mean(brain_val$Brain.weight))^2)
  R2 = 1-RSS/TSS
  rmse[i,] <- data.frame(i, sqrt(mean(dif^2)), R2)
}
```
    b. Plot the validation RMSE as a function of $K$ and select the best K.
```{r}
library(ggplot2)
ggplot(data = rmse)+
  geom_line(mapping = aes(x = k, y = rmse))+
  labs(x = "k", y ="rmse")
```

```{r}
library(dplyr)
rmse<-arrange(rmse, rmse, .by_group = FALSE)
head(rmse, 1)
```
    c. Using the validation RMSE compare to the best linear regression model from homework 1. Is there an improvement in prediction performance?  Interpret your results based on the bias-variance tradeoff.

The prediction performance didn't improve using KNN method, probably because of overfitting by focusing too much on the training model.

<br>



2. The goal of this exercise is to fit several LDA classifiers and perform model selection using the Ischemic Stroke data set. For your convenience the code to pre-process/transform the data is provided below.

**Dataset notes:**
According to the Mayo Clinic, "ischemic stroke occurs when a blood clot blocks or narrows an artery leading to the brain. A blood clot often forms in arteries damaged by the buildup of plaques (atherosclerosis). It can occur in the carotid artery of the neck as well as other arteries. This is the most common type of stroke." (https://www.mayoclinic.org/diseases-conditions/stroke/symptoms-causes/syc-20350113#:~:text=Ischemic%20stroke%20occurs%20when%20a,most%20common%20type%20of%20stroke.)

a. When splitting the data into training, validation and testing or classification problems it is important to ensure each set retains approximately the same proportion of positive and negative examples as the full data. Split the data into training (70%), and validation (30%), but keeping the proportion of positive and negative examples roughly the same in the training and validation sets. This can be accomplished by sampling in a stratified manner, i.e. sampling 70/30 within the negative and the positive classes. Use the code below to perform stratified splitting. 
```{r eval=TRUE, results="Hide"}
# Code for reading in stroke data and converting categorical variables to factors 
# To run chunk set options above to eval=TRUE 

stroke = read.csv("stroke.csv" )
str(stroke)

stroke$Stroke                      <- factor(stroke$Stroke, levels=c('N', 'Y'), labels=c("No", "Yes"))
stroke$NASCET                      <- factor(stroke$NASCET, levels=0:1, labels=c("No", "Yes"))
stroke$sex                         <- factor(stroke$sex, levels=0:1, labels=c("Female", "Male"))
stroke$SmokingHistory              <- factor(stroke$SmokingHistory, levels=0:1, labels=c("No", "Yes"))
stroke$AtrialFibrillation          <- factor(stroke$AtrialFibrillation, levels=0:1, labels=c("No", "Yes"))
stroke$CoronaryArteryDisease       <- factor(stroke$CoronaryArteryDisease, levels=0:1, labels=c("No", "Yes"))
stroke$DiabetesHistory             <- factor(stroke$DiabetesHistory, levels=0:1, labels=c("No", "Yes"))
stroke$HypercholesterolemiaHistory <- factor(stroke$HypercholesterolemiaHistory, levels=0:1, labels=c("No", "Yes"))
stroke$HypertensionHistory         <- factor(stroke$HypertensionHistory, levels=0:1, labels=c("No", "Yes"))
```

```{r eval=TRUE}
# Code for splitting data into trainin and validation 
# To run chunk set options above to eval=TRUE 

n = nrow(stroke)
positives = (1:n)[stroke$Stroke=='Yes']
negatives = (1:n)[stroke$Stroke=='No']

positives_train = sample(positives, floor(0.7*length(positives)))
positives_val = setdiff(positives, positives_train)

negatives_train = sample(negatives, floor(0.7*length(negatives)))
negatives_val = setdiff(negatives, negatives_train)

stroke_train = stroke[c(positives_train, negatives_train), ]
stroke_val = stroke[c(positives_val, negatives_val), ]

ntrain = nrow(stroke_train); nval=nrow(stroke_val)

table(stroke_train$Stroke)
table(stroke_val$Stroke)
```


Note: Because of the moderate sample size we will not have a separate test set -- we will learn later in the course about cross-validation, which will allow us to split the data into training and testing only and still perform model selection.
    
a. Read in the data and convert all categorical variables to factors (use code below). Split the data into a training (70%) and validation (30%) using stratified dampling (use code below). Using the training data, graphically assess each of the predictors using a boxplot for quantitative predictors and a mosaic plot for a categorical predictors. Note: you can use plot to get these graphs. Use for example ``boxplot(your_predictor ~ Stroke, data=stroke_train)`` to get a boxplot for a quantitative predictor and ``plot(Stroke, your_predictor, data=stroke_train)`` for a categorical predictor to get a mosaic plot. Visually determine the 3 most most predictive **imaging features**, i.e. the imaging features that best separate the stroke=YES vs. stroke='No' classes. (This is an informal procedure since a visual assessment is inherently subjective, in a future class we will learn how to do feature selection in a systematic way).
```{r}
boxplot(CALCVol~Stroke, data = stroke_train)
boxplot(CALCVolProp~Stroke, data = stroke_train)
boxplot(MATXVol~Stroke, data = stroke_train)
boxplot(MATXVolProp~Stroke, data = stroke_train)
boxplot(LRNCVol~Stroke, data = stroke_train)
boxplot(LRNCVolProp~Stroke, data = stroke_train)
boxplot(MaxCALCArea~Stroke, data = stroke_train)
boxplot(MaxCALCAreaProp~Stroke, data = stroke_train)
boxplot(MaxDilationByArea~Stroke, data = stroke_train)
boxplot(MaxMATXArea~Stroke, data = stroke_train)
boxplot(MaxMATXAreaProp~Stroke, data = stroke_train)
boxplot(MaxLRNCArea~Stroke, data = stroke_train)
boxplot(MaxMaxWallThickness~Stroke, data = stroke_train)
boxplot(MaxRemodelingRatio~Stroke, data = stroke_train)
boxplot(MaxStenosisByArea~Stroke, data = stroke_train)
boxplot(MaxWallArea~Stroke, data = stroke_train)
boxplot(WallVol~Stroke, data = stroke_train)
boxplot(MaxStenosisByDiameter~Stroke, data = stroke_train)
boxplot(age~Stroke, data = stroke_train)

plot(Stroke~NASCET, data=stroke_train)
plot(Stroke~sex, data = stroke_train)
plot(Stroke~SmokingHistory, data = stroke_train)
plot(Stroke~AtrialFibrillation, data = stroke_train)
plot(Stroke~CoronaryArteryDisease, data = stroke_train)
plot(Stroke~DiabetesHistory, data = stroke_train)
plot(Stroke~HypercholesterolemiaHistory, data = stroke_train)
plot(Stroke~HypertensionHistory, data = stroke_train)
```
    
b. Build LDA classifiers of increasing complexity by including: i) age, sex, and smoking history; ii) all the previous features  + the clinical variables AtrialFibrillation, CoronaryArteryDisease, DiabetesHistory, HypercholesterolemiaHistory, and HypertensionHistory; iii) all the previous features + the most predictive imaging feature based on part b; and iv) all the previous features + the next 2 most predictive imaging features.
```{r warning = FALSE, message = FALSE}
require(MASS)
stroke_lda = lda(Stroke ~ age + sex + SmokingHistory , data=stroke_train)
stroke_lda
```

```{r}
stroke_lda2 = lda(Stroke ~ age + sex + SmokingHistory + AtrialFibrillation + CoronaryArteryDisease + DiabetesHistory + HypercholesterolemiaHistory + HypertensionHistory , data=stroke_train)
stroke_lda2
```

```{r}
stroke_lda3 <- lda(Stroke ~ age + sex + SmokingHistory + AtrialFibrillation + CoronaryArteryDisease + DiabetesHistory + HypercholesterolemiaHistory + HypertensionHistory + MaxMaxWallThickness, data=stroke_train)
stroke_lda3
```
```{r}
stroke_lda4 <- lda(Stroke ~ age + sex + SmokingHistory + AtrialFibrillation + CoronaryArteryDisease + DiabetesHistory + HypercholesterolemiaHistory + HypertensionHistory + MaxMaxWallThickness + MaxStenosisByArea + MATXVol, data=stroke_train)
stroke_lda4
```   
    
c. Write an R function ``classificationError`` to compute the overall misclassification error, specificity, and sensitivity of a classifier. The function should take a confusion matrix as its input (which you can create using ``table`` as shown in the lecture) and return a vector with the overall misclassication error, specificity and sensitivity. (Hint: separately compute the three quantities ``error``, ``spec``, and ``sens`` inside the body of the function and then put them together in a vector using ``c(error=error, sensitivity=sens, specificity=spec)`` in the last line of the body of the function before the closing ``}`` -- the last line is by default what a function returns. The returned object can be any R object including a siggle number, a vector, a data.frame or even another function!)
```{r}
ClassificationError<-function(confmatrix){
  error = round((confmatrix[1,2]+confmatrix[2,1])/(confmatrix[1,1]+confmatrix[1,2]+confmatrix[2,1]+confmatrix[2,2]),2)
  spec = round(confmatrix[1,1]/(confmatrix[1,1]+confmatrix[1,2]),2)
  sens = round(confmatrix[2,2]/(confmatrix[2,1]+confmatrix[2,2]),2)
  print(c(error=error, sensitivity=sens, specificity=spec))
}
```

d. Compute the training and test errors for each of the classifiers in e. Which classifier would you choose?
```{r}
pred_lda_train = predict(stroke_lda, newdata=stroke_train)
confMatrix_train = table(true=stroke_train$Stroke, predicted=pred_lda_train$class)
trainer1<-ClassificationError(confMatrix_train)

pred_lda_train2 = predict(stroke_lda2, newdata=stroke_train)
confMatrix_train2 = table(true=stroke_train$Stroke, predicted=pred_lda_train2$class)
trainer2<-ClassificationError(confMatrix_train2)

pred_lda_train3 = predict(stroke_lda3, newdata=stroke_train)
confMatrix_train3 = table(true=stroke_train$Stroke, predicted=pred_lda_train3$class)
trainer3<-ClassificationError(confMatrix_train3)

pred_lda_train4 = predict(stroke_lda4, newdata=stroke_train)
confMatrix_train4 = table(true=stroke_train$Stroke, predicted=pred_lda_train4$class)
trainer4<-ClassificationError(confMatrix_train4)
```

```{r}
pred_lda_val = predict(stroke_lda, newdata=stroke_val)
confMatrix_val = table(true=stroke_val$Stroke, predicted=pred_lda_val$class)
tester1<-ClassificationError(confMatrix_val)

pred_lda_val2 = predict(stroke_lda2, newdata=stroke_val)
confMatrix_val2 = table(true=stroke_val$Stroke, predicted=pred_lda_val2$class)
tester2<-ClassificationError(confMatrix_val2)

pred_lda_val3 = predict(stroke_lda3, newdata=stroke_val)
confMatrix_val3 = table(true=stroke_val$Stroke, predicted=pred_lda_val3$class)
tester3<-ClassificationError(confMatrix_val3)

pred_lda_val4 = predict(stroke_lda4, newdata=stroke_val)
confMatrix_val4 = table(true=stroke_val$Stroke, predicted=pred_lda_val4$class)
tester4<-ClassificationError(confMatrix_val4)
```



```{r}
train_error <- c(trainer1[1], trainer2[1], trainer3[1],trainer4[1])
test_error <- c(tester1[1], tester2[1], tester3[1],tester4[1])
complexity <- c(1,2,3,4)
tb <- data.frame(train_error, test_error, complexity)
knitr::kable(tb)
```
e. Plot in the same graph the training and test misclassification error as a function of classifier complexity. Comment/interpret the plots.
```{r}
ggplot(data = tb) +
  geom_line(mapping = aes(x = complexity, y = train_error, color = "train error")) +
  geom_line(mapping = aes(x = complexity, y = test_error, color = "test error")) +
  labs(x = "classifier complexity", y = "misclassification error", title = "Lineplot of misclassification and complexity") 
```

```{r}
cor.test(complexity,train_error)
cor.test(complexity,test_error)
```
The misclassification error of both train set and validation set both decreases as the classifier increases. The test on correlation coefficients show that there are significant linear association on complexity and misclassification error. 



 
